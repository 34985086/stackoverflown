Since you're adding additional edges into the grid, you have to convert the original layout into an equivalent layout with additional rows and columns that will cover those edges.

I've written a solution for that some time ago. Below are my notes and code extract.

A general approach might be to iterate over all items, and for each item whose row/column spans gaps, generate a new fill that fills the gaps, then recurse into the layout. This will generate multiple alternative fills, and which one ends up chosen is arbitrary. For the chosen fill, new rows/columns have to be generated to fulfill the constraints. This will be the solution. An additional simplification pass can remove rows/columns that consist only of span extensions.

Let's look at examples. We'll consider all possible paths, noting that several of them are equivalent. Subsequences of non-interacting fills that yield same fills are considered equivalent, e.g. below 0 row, 2 row is equivalent to 2 row, 0 row. First, a dense layout without spans:

    [0]---[6]
    [1][4][7]
    [2][5]---

    0 row       2 row      solution
    [06     ]   [06     ]  [0   ][6   ] 3x4=12
    [1][4][7]   [1][4][7]  [1][4   ][7]
    [2][5]---   [25     ]  [2   ][5   ]

                7 column   solution
                [06     ]  [0   ][6  ] 3x4=12
                [1][4][7]  [1][4  ][7]
                [2][5]| |  [2][5  ]| |

    6 column    0 row      solution   simplified
    [0]---[6]   [0   ][6]  [0   ][6]  [0   ][6]  4x3=12
    [1][4]|7|   [1][4]|7|  |    || |  [1][4]| |
    [2][5]| |   [2][5]| |  [1][4]| |  | || |[7]
                           | || |[7]  [2][5]| |
                           [2][5]| |
                           | || || |

A sparser layout with spans:

    [0]---[6]
    ---[4]| |
    ---| |---

    0 row      4 row      6 column   solution   simplified
    [0   ][6]  [0   ][6]  [0   ][6]  [0   ][6]  [0][6] 2x2=4
    ---[4]| |  [4   ]| |  [4   ]| |  [4   ]| |  [4]| |
    ---| |---  |    |---  |    || |  |    || |

    4 column   0 column   6 column   solution   simplified
    [0][4][6]  [0][4][6]  [0][4][6]  [0][4][6]  [0][4][6] 1x3=3
    ---| || |  | || || |  | || || |  | || || |
    ---| |---  | || |---  | || || |  | || || |


Another example:

    [0]---[6]
    ---[4][7]
    ---| |---

    0 row      4 row      7 column   solution      simplified
    [06     ]  [06     ]  [06     ]  [0   ][6   ]  [0][6   ]  2x3=6
    ---[4][7]  [4   ][7]  [4   ][7]  [4      ][7]  [4   ][7]
    ---| |---  |    |---  |    || |  |       || |

               7 column   4 row      solution      simplified
               [06     ]  [06     ]  [0   ][6   ]  [0][6]  2x2=4
               ---[4][7]  [47     ]  [4   ][7   ]  [4][7]
               ---| || |  |       |  |    ||    |

    6 column   0 row     4 row      solution   simplified
    [0]---[6]  [0   ][6] [0   ][6]  [0   ][6]  [0][6]  3x2=6
    ---[4]|7|  ---[4]|7| [4   ]|7|  [4   ]| |  [4]| |
    ---| || |  ---| || | |    || |  |    |[7]  | |[7]
                                    |    || |

The properties of the solutions depend on the sequence of fill steps. We can choose the simplified solution based on the overall size, preferring smaller sizes. Tie breaking can be done in any number of ways. For simplicity choose the first of the smallest solutions in the fill order.

The fill steps use the rows and columns of the original layout. The solution step adds additional rows/columns to fulfill the constraints. Let's look at examples from above in detail:

    [06     ]
    [1][4][7]
    [25     ]

Following are the fills. Each fill spans a closed-open cell range:

    0,0-1,3 [0,6]
    1,0-2,1 [1]
    1,1-2,2 [4]
    1,2-2,3 [7]
    2,0-3,3 [2,5]

The fills are then converted to elements with rational coordinate ranges, and the horizontal and vertical coordinates are all brought to their own common denominators, we only show the numerators for simplicity:

        rational     denominators 1,2
    [0] 0,0-1,3/2    0,0-1,3
    [6] 0,3/2-1,3    0,3-1,6
    [1] 1,0-2,1      1,0-2,2
    [4] 1,1-2,2      1,2-2,4
    [7] 1,2-2,3      1,4-2,6
    [2] 0,0-1,3/2    0,0-1,3
    [5] 0,3/2-1,3    0,3-1,6

The denominators are dropped, and the row and column coordinates are collected and sorted, and have rows/columns in the solution assigned to them sequentially:

    rows: 0->r0, 1->r1, 2->r2, 3->X3
    columns 0->c0, 2->c1, 3->c2, 4->c3, 6->X4

Using this mapping, we convert fills from abstract coordinates to row/column ranges in the solution:

    [0] 0,0-1,2
    [6] 0,2-1,X4
    [1] 1,0-2,1
    [4] 1,1-2,3
    [7] 1,3-2,X4
    [2] 0,0-1,2
    [5] 0,2-1,X4

And thus the solution:

       00 01 02 03
    00 [0   ][6   ]
    01 [1][4   ][7]
    02 [2   ][5   ]

