/****************************************************************************
**
** Copyright (C) 2017 Kuba Ober
**
** Permission is hereby granted, free of charge, to any person obtaining
** a copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
**  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
** THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
**
****************************************************************************/

#include "sojsextension.h"

/* This plugin allows easy retrieval of code from StackOverflow questions.
 * The code can be used e.g. in a project creation wizard.
 *
 * We're only interested in the question's .items and body_markdown.
 * This filter id is !VYNqt3Opi and it's generated by
 * http://api.stackexchange.com/docs/create-filter#include=.items%3Bquestion.body_markdown&base=none&unsafe=false&filter=default&run=true
 */

#include <QCoreApplication>
#include <QEventLoop>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QNetworkReply>
#include <QRegularExpression>
#include <QTimer>

#include <utils/networkaccessmanager.h>

namespace StackOverflow {
namespace Internal {

SOJsExtension::SOJsExtension(QObject *parent) : QObject(parent)
{}

static QNetworkReply *getData(QNetworkAccessManager *manager, const QUrl &url, int timeout)
{
    // This is not very nice but we don't have much choice.
    // The only other solution is to use an asynchronous fetch from the wizard page -
    // it'd be a hack, but a nice hack nevertheless.
    Q_ASSERT(timeout > 0);
    auto reply = manager->get(QNetworkRequest(url));
    QEventLoop loop;
    QTimer::singleShot(timeout, &loop, &QEventLoop::quit);
    QObject::connect(reply, &QNetworkReply::finished, &loop, &QEventLoop::quit);
    if (!reply->isFinished())
        loop.exec();
    return reply;
}

static QString decodeEntities(const QString & str)
{
    QString result;
    QRegularExpression re("&#([0-9]+);");
    auto it = re.globalMatch(str);
    int lastEnd = 0;
    while (it.hasNext()) {
        auto match = it.next();
        auto start = match.capturedStart(0);
        auto end = match.capturedEnd(0);
        result.append(str.mid(lastEnd, start-lastEnd));
        result.append(QChar(match.captured(1).toInt({}, 10)));
        lastEnd = end;
    }
    result.append(str.mid(lastEnd));
    result.replace("&quot;", "\"");
    result.replace("&lt;", "<");
    result.replace("&gt;", ">");
    result.replace("&amp;", "&");
    return result;
}

static QString decodeQuestion(const QByteArray & json) {
    auto doc = QJsonDocument::fromJson(json);
    auto obj = doc.object();
    auto items = obj["items"].toArray();
    auto item = items.first().toObject();
    auto body_markdown = item["body_markdown"].toString();
    return decodeEntities(body_markdown);
}

QString SOJsExtension::getQuestionCode(const QString & questionId) {
    if (questionId.isEmpty())
        return QString();
    auto manager = Utils::NetworkAccessManager::instance();
    QUrl api(QStringLiteral("http://api.stackexchange.com/2.2/questions/%1?"
                            "order=desc&sort=activity&site=stackoverflow&filter=!VYNqt3Opi")
             .arg(questionId));
    QScopedPointer<QNetworkReply> reply(getData(manager, api, 2000));
    m_status = reply->errorString();
    if (!reply->isFinished())
        return QStringLiteral("The network request timed out.");
    if (reply->error() != QNetworkReply::NoError)
        return QString();
    return decodeQuestion(reply->readAll());
}

QString SOJsExtension::getStatus() const {
    return m_status;
}

} // namespace Internal
} // namespace StackOverflow
