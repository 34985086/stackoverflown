/****************************************************************************
**
** Copyright (C) 2017 Kuba Ober
**
** Permission is hereby granted, free of charge, to any person obtaining
** a copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
**  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
** THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
**
****************************************************************************/

#include "sojsextension.h"

/* This plugin allows easy retrieval of code from StackOverflow questions.
 * The code can be used e.g. in a project creation wizard.
 *
 * We're only interested in the question's .items and body_markdown.
 * This filter id is !VYNqt3Opi and it's generated by
 * http://api.stackexchange.com/docs/create-filter#include=.items%3Bquestion.body_markdown&base=none&unsafe=false&filter=default&run=true
 */

#include <QCoreApplication>
#include <QEventLoop>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QNetworkReply>
#include <QRegularExpression>
#include <QTimer>

#include <utils/networkaccessmanager.h>

namespace StackOverflow {
namespace Internal {

SOJsExtension::CacheItem::CacheItem(const QUrl &url, int timeout, qint64 maxSize) :
    timeout(timeout),
    reply(Utils::NetworkAccessManager::instance()->get(QNetworkRequest(url)))
{
    Q_ASSERT(timeout > 0);
    auto reply = this->reply.data();
    QTimer::singleShot(timeout, Qt::CoarseTimer, reply, [reply]{
        if (!reply->isFinished())
            reply->abort();
    });
    QObject::connect(reply, &QNetworkReply::finished, this, [this]{
        data = this->reply->readAll();
    });
    QObject::connect(reply, &QIODevice::readyRead, this, [reply, maxSize]{
        if (reply->bytesAvailable() > maxSize)
            reply->abort();
    });
}

void SOJsExtension::CacheItem::waitForFinished() {
    QEventLoop loop;
    QObject::connect(reply.data(), &QNetworkReply::finished, &loop, &QEventLoop::quit);
    if (!reply->isFinished())
        loop.exec();
}

static QString decodeEntities(const QString &str)
{
    QString result;
    result.reserve(str.size());
    QRegularExpression re("&#([0-9]+);");
    auto it = re.globalMatch(str);
    int lastEnd = 0;
    while (it.hasNext()) {
        auto match = it.next();
        auto start = match.capturedStart(0);
        auto end = match.capturedEnd(0);
        result.append(str.mid(lastEnd, start-lastEnd));
        result.append(QChar(match.captured(1).toInt({}, 10)));
        lastEnd = end;
    }
    result.append(str.mid(lastEnd));
    result.replace("&quot;", "\"");
    result.replace("&lt;", "<");
    result.replace("&gt;", ">");
    result.replace("&amp;", "&");
    return result;
}

static QString decodeQuestion(const QByteArray &json)
{
    auto doc = QJsonDocument::fromJson(json);
    auto obj = doc.object();
    auto items = obj["items"].toArray();
    auto item = items.first().toObject();
    auto body_markdown = item["body_markdown"].toString();
    return decodeEntities(body_markdown);
}

static QUrl questionBodyUrl(qint64 id) {
    return {QStringLiteral("http://api.stackexchange.com/2.2/questions/%1?"
                           "order=desc&sort=activity&site=stackoverflow&filter=!VYNqt3Opi")
                .arg(id)};
}

static qint64 questionId(const QString &question)
{
    bool ok;
    if (question.isEmpty())
        return -1;

    // Numerical Id
    QRegularExpression re("^[0-9]+$");
    auto match = re.match(question);
    if (match.hasMatch()) {
        auto id = question.toLongLong(&ok);
        return ok ? id : -1;
    }

    // URL
    QUrl url(question);
    if (!url.isValid())
        return -1;
    auto scheme = url.scheme().toLower();
    if (scheme != "http" && scheme != "https")
        return -1;
    re = QRegularExpression("^/questions/([0-9]+)/");
    match = re.match(url.path());
    if (!match.hasMatch())
        return -1;
    auto id = match.captured(1).toLongLong(&ok);
    return ok ? id : -1;
}

CachedReply *SOJsExtension::getItem(qint64 id)
{
    if (id == -1)
        return nullptr;
    return m_cache.getReply(id, {questionBodyUrl(id)}, m_fetchTimeout, m_maxQuestionBodySize);
    return item;
}

SOJsExtension::SOJsExtension(QObject *parent) :
    QObject(parent),
    m_fetchTimeout(2000)
{}

bool SOJsExtension::prefetchQuestionBody(const QString &question)
{
    auto id = questionId(question);
    getItem(id);
    return true;
}

QString SOJsExtension::getQuestionBody(const QString &question)
{
    auto id = questionId(question);
    auto item = getItem(id);
    if (!item)
        return QString();
    item->waitForFinished();
    if (item->hasError())
        return QString();
    return decodeQuestion(item->data);
}

QString SOJsExtension::getStatus(const QString &question) const
{
    auto id = questionId(question);
    auto item = m_cache.object(id);
    return item ? item->reply->errorString() : "Unknown Status";
}

} // namespace Internal
} // namespace StackOverflow
